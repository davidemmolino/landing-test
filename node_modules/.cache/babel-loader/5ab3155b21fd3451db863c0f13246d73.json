{"ast":null,"code":"import React, { useState, useEffect } from 'react';\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilSnapshot, useGotoRecoilSnapshot } from 'recoil';\nimport { formatFiberNodes } from './formatFiberNodes'; // grabs isPersistedState from sessionStorage\n\nlet isPersistedState = sessionStorage.getItem('isPersistedState'); // isRestored state disables snapshots from being recorded\n// when we jump backwards\n\nlet isRestoredState = false; // set default throttle to 70, throttle timer changes with every snapshot\n\nlet throttleTimer = 0;\nlet throttleLimit = 70; // persistedSnapshots initially null\n// let persistedSnapshots = null;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  // Define a recoilizeRoot variable which will be assigned based on whether a root is passed in as a prop\n  let recoilizeRoot; // Check if a root was passed to props.\n\n  if (props.root) {\n    const {\n      root\n    } = props;\n    recoilizeRoot = root;\n  } else {\n    recoilizeRoot = document.getElementById('root');\n  }\n\n  const snapshot = useRecoilSnapshot(); // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\n\n  const nodes = [...snapshot.getNodes_UNSTABLE()]; // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n\n  const [snapshots, setSnapshots] = useState([snapshot]); // const [isRestoredState, setRestoredState] = useState(false);\n\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n  /*\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \n  This object will then be used to construct a nodeSubscriptions object. \n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \n  */\n\n  const nodeDeps = {};\n  const nodeSubscriptions = {};\n  nodes.forEach(node => {\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\n  });\n\n  for (let key in nodeDeps) {\n    nodeDeps[key].forEach(node => {\n      if (nodeSubscriptions[node]) {\n        nodeSubscriptions[node].push(key);\n      } else {\n        nodeSubscriptions[node] = [key];\n      }\n    });\n  } // Traverse all atoms and selector state nodes and get value\n\n\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents; // Construct node data structure for dev tool to consume\n\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps[node.key],\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key] ? nodeSubscriptions[node.key] : []\n    };\n  }); // React lifecycle hook on re-render\n\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener('message', onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot); // Post message to content script on every re-render of the developers application only if content script has started\n\n      sendWindowMessage('recordSnapshot', devToolData);\n    } else {\n      isRestoredState = false;\n    } // Clears the window event listener.\n\n\n    return () => window.removeEventListener('message', onMessageReceived);\n  }); // Listener callback for messages sent to windowf\n\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case 'contentScriptStarted':\n        if (isPersistedState === 'false' || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(filteredSnapshot); //creating a indexDiff variable\n          //only created on initial creation of devToolData\n          //determines difference in length of backend snapshots array and frontend snapshotHistoryLength to avoid off by one error\n\n          const indexDiff = snapshots.length - 1;\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot, indexDiff);\n          sendWindowMessage('moduleInitialized', devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage('persistSnapshots', null);\n        }\n\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n\n      case 'snapshotTimeTravel':\n        timeTravelToSnapshot(msg);\n        break;\n\n      case 'persistState':\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n\n      case 'throttleEdit':\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  }; // assigns or switches isPersistedState in sessionStorage\n\n\n  const switchPersistMode = () => {\n    if (isPersistedState === 'false' || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem('isPersistedState', true); // stores the length of current list of snapshots in sessionStorage\n\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem('isPersistedState', false);\n    }\n  }; // function retreives length and fills snapshot array\n\n\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem('persistedSnapshots');\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  }; // Sends window an action and payload message.\n\n\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage({\n      action,\n      payload\n    }, '*');\n  };\n\n  const createDevToolDataObject = (filteredSnapshot, diff) => {\n    if (diff === undefined) {\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(recoilizeRoot._reactRootContainer._internalRoot.current)\n      };\n    } else {\n      console.log('logging diff from create Dev tool data:', diff);\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(recoilizeRoot._reactRootContainer._internalRoot.current),\n        indexDiff: diff\n      };\n    }\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (window.$recoilDebugStates && Array.isArray(window.$recoilDebugStates) && window.$recoilDebugStates.length) {\n      let snapObj = window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n\n      if (snapObj.hasOwnProperty('nodeDeps')) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n\n    return filteredSnapshot;\n  }; // Will add hover effect over highlighted component\n  // Takes an argument of msg.data which contains name and payload\n\n\n  const activateHover = payload => {\n    let name = payload.name;\n    console.log('hello from index.js');\n  }; // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n\n\n  const timeTravelToSnapshot = async msg => {\n    // await setRestoredState(true);\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n    // await setRestoredState(false);\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  }; // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n\n\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    const now = new Date().getTime();\n\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}","map":{"version":3,"sources":["/home/davide/Desktop/Recoilize-landing-page/node_modules/recoilize/index.js"],"names":["React","useState","useEffect","useRecoilTransactionObserver_UNSTABLE","useRecoilSnapshot","useGotoRecoilSnapshot","formatFiberNodes","isPersistedState","sessionStorage","getItem","isRestoredState","throttleTimer","throttleLimit","RecoilizeDebugger","props","recoilizeRoot","root","document","getElementById","snapshot","nodes","getNodes_UNSTABLE","snapshots","setSnapshots","gotoSnapshot","filteredSnapshot","nodeDeps","nodeSubscriptions","forEach","node","getDeps","getDeps_UNSTABLE","key","map","dep","push","index","type","__proto__","constructor","name","contents","getLoadable","nodeToNodeSubscriptions","window","addEventListener","onMessageReceived","devToolData","createDevToolDataObject","sendWindowMessage","removeEventListener","msg","data","action","initialFilteredSnapshot","formatAtomSelectorRelationship","indexDiff","length","setProperIndexForPersistedState","timeTravelToSnapshot","switchPersistMode","parseInt","payload","value","setItem","retreived","snapshotsArray","Array","Number","fill","postMessage","diff","undefined","componentAtomTree","_reactRootContainer","_internalRoot","current","console","log","$recoilDebugStates","isArray","snapObj","hasOwnProperty","from","activateHover","snapshotIndex","now","Date","getTime"],"mappings":"AAAA,OAAOA,KAAP,IAAeC,QAAf,EAAyBC,SAAzB,QAAyC,OAAzC;AACA,SACEC,qCADF,EAEEC,iBAFF,EAGEC,qBAHF,QAIO,QAJP;AAKA,SAAQC,gBAAR,QAA+B,oBAA/B,C,CAEA;;AACA,IAAIC,gBAAgB,GAAGC,cAAc,CAACC,OAAf,CAAuB,kBAAvB,CAAvB,C,CAEA;AACA;;AACA,IAAIC,eAAe,GAAG,KAAtB,C,CAEA;;AACA,IAAIC,aAAa,GAAG,CAApB;AACA,IAAIC,aAAa,GAAG,EAApB,C,CAEA;AACA;;AAEA,eAAe,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAC/C;AACA;AAEA;AACA,MAAIC,aAAJ,CAL+C,CAO/C;;AACA,MAAID,KAAK,CAACE,IAAV,EAAgB;AACd,UAAM;AAACA,MAAAA;AAAD,QAASF,KAAf;AACAC,IAAAA,aAAa,GAAGC,IAAhB;AACD,GAHD,MAGO;AACLD,IAAAA,aAAa,GAAGE,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAAhB;AACD;;AAED,QAAMC,QAAQ,GAAGf,iBAAiB,EAAlC,CAf+C,CAiB/C;;AACA,QAAMgB,KAAK,GAAG,CAAC,GAAGD,QAAQ,CAACE,iBAAT,EAAJ,CAAd,CAlB+C,CAoB/C;;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BtB,QAAQ,CAAC,CAACkB,QAAD,CAAD,CAA1C,CArB+C,CAsB/C;;AACA,QAAMK,YAAY,GAAGnB,qBAAqB,EAA1C;AAEA,QAAMoB,gBAAgB,GAAG,EAAzB;AAEA;AACF;AACA;AACA;AACA;;AAEE,QAAMC,QAAQ,GAAG,EAAjB;AACA,QAAMC,iBAAiB,GAAG,EAA1B;AAEAP,EAAAA,KAAK,CAACQ,OAAN,CAAcC,IAAI,IAAI;AACpB,UAAMC,OAAO,GAAG,CAAC,GAAGX,QAAQ,CAACY,gBAAT,CAA0BF,IAA1B,CAAJ,CAAhB;AACAH,IAAAA,QAAQ,CAACG,IAAI,CAACG,GAAN,CAAR,GAAqBF,OAAO,CAACG,GAAR,CAAYC,GAAG,IAAIA,GAAG,CAACF,GAAvB,CAArB;AACD,GAHD;;AAKA,OAAK,IAAIA,GAAT,IAAgBN,QAAhB,EAA0B;AACxBA,IAAAA,QAAQ,CAACM,GAAD,CAAR,CAAcJ,OAAd,CAAsBC,IAAI,IAAI;AAC5B,UAAIF,iBAAiB,CAACE,IAAD,CAArB,EAA6B;AAC3BF,QAAAA,iBAAiB,CAACE,IAAD,CAAjB,CAAwBM,IAAxB,CAA6BH,GAA7B;AACD,OAFD,MAEO;AACLL,QAAAA,iBAAiB,CAACE,IAAD,CAAjB,GAA0B,CAACG,GAAD,CAA1B;AACD;AACF,KAND;AAOD,GAjD8C,CAmD/C;;;AACAZ,EAAAA,KAAK,CAACQ,OAAN,CAAc,CAACC,IAAD,EAAOO,KAAP,KAAiB;AAC7B,UAAMC,IAAI,GAAGR,IAAI,CAACS,SAAL,CAAeC,WAAf,CAA2BC,IAAxC;AACA,UAAMC,QAAQ,GAAGtB,QAAQ,CAACuB,WAAT,CAAqBb,IAArB,EAA2BY,QAA5C,CAF6B,CAG7B;;AACAhB,IAAAA,gBAAgB,CAACI,IAAI,CAACG,GAAN,CAAhB,GAA6B;AAC3BK,MAAAA,IAD2B;AAE3BI,MAAAA,QAF2B;AAG3Bf,MAAAA,QAAQ,EAAEA,QAAQ,CAACG,IAAI,CAACG,GAAN,CAHS;AAI3BW,MAAAA,uBAAuB,EAAEhB,iBAAiB,CAACE,IAAI,CAACG,GAAN,CAAjB,GACrBL,iBAAiB,CAACE,IAAI,CAACG,GAAN,CADI,GAErB;AANuB,KAA7B;AAQD,GAZD,EApD+C,CAkE/C;;AACA9B,EAAAA,SAAS,CAAC,MAAM;AACd;AACA0C,IAAAA,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmCC,iBAAnC;;AAEA,QAAI,CAACpC,eAAL,EAAsB;AACpB,YAAMqC,WAAW,GAAGC,uBAAuB,CAACvB,gBAAD,CAA3C,CADoB,CAEpB;;AACAwB,MAAAA,iBAAiB,CAAC,gBAAD,EAAmBF,WAAnB,CAAjB;AACD,KAJD,MAIO;AACLrC,MAAAA,eAAe,GAAG,KAAlB;AACD,KAVa,CAYd;;;AACA,WAAO,MAAMkC,MAAM,CAACM,mBAAP,CAA2B,SAA3B,EAAsCJ,iBAAtC,CAAb;AACD,GAdQ,CAAT,CAnE+C,CAmF/C;;AACA,QAAMA,iBAAiB,GAAGK,GAAG,IAAI;AAC/B;AACA,YAAQA,GAAG,CAACC,IAAJ,CAASC,MAAjB;AACE;AACA,WAAK,sBAAL;AACE,YAAI9C,gBAAgB,KAAK,OAArB,IAAgCA,gBAAgB,KAAK,IAAzD,EAA+D;AAC7D,gBAAM+C,uBAAuB,GAAGC,8BAA8B,CAC5D9B,gBAD4D,CAA9D,CAD6D,CAK7D;AACA;AACA;;AACA,gBAAM+B,SAAS,GAAGlC,SAAS,CAACmC,MAAV,GAAmB,CAArC;AAEA,gBAAMV,WAAW,GAAGC,uBAAuB,CACzCM,uBADyC,EAEzCE,SAFyC,CAA3C;AAIAP,UAAAA,iBAAiB,CAAC,mBAAD,EAAsBF,WAAtB,CAAjB;AACD,SAfD,MAeO;AACLW,UAAAA,+BAA+B;AAC/BT,UAAAA,iBAAiB,CAAC,kBAAD,EAAqB,IAArB,CAAjB;AACD;;AACD;AACF;;AACA,WAAK,oBAAL;AACEU,QAAAA,oBAAoB,CAACR,GAAD,CAApB;AACA;;AACF,WAAK,cAAL;AACES,QAAAA,iBAAiB;AACjB;AACF;;AACA,WAAK,cAAL;AACEhD,QAAAA,aAAa,GAAGiD,QAAQ,CAACV,GAAG,CAACC,IAAJ,CAASU,OAAT,CAAiBC,KAAlB,CAAxB;AACA;;AACF;AACE;AAnCJ;AAqCD,GAvCD,CApF+C,CA6H/C;;;AACA,QAAMH,iBAAiB,GAAG,MAAM;AAC9B,QAAIrD,gBAAgB,KAAK,OAArB,IAAgCA,gBAAgB,KAAK,IAAzD,EAA+D;AAC7D;AACAC,MAAAA,cAAc,CAACwD,OAAf,CAAuB,kBAAvB,EAA2C,IAA3C,EAF6D,CAI7D;;AACAxD,MAAAA,cAAc,CAACwD,OAAf,CAAuB,oBAAvB,EAA6C1C,SAAS,CAACmC,MAAvD;AACD,KAND,MAMO;AACL;AACAjD,MAAAA,cAAc,CAACwD,OAAf,CAAuB,kBAAvB,EAA2C,KAA3C;AACD;AACF,GAXD,CA9H+C,CA2I/C;;;AACA,QAAMN,+BAA+B,GAAG,MAAM;AAC5C,UAAMO,SAAS,GAAGzD,cAAc,CAACC,OAAf,CAAuB,oBAAvB,CAAlB;AACA,UAAMyD,cAAc,GAAG,IAAIC,KAAJ,CAAUC,MAAM,CAACH,SAAD,CAAN,GAAoB,CAA9B,EAAiCI,IAAjC,CAAsC,EAAtC,CAAvB;AACA9C,IAAAA,YAAY,CAAC2C,cAAD,CAAZ;AACD,GAJD,CA5I+C,CAkJ/C;;;AACA,QAAMjB,iBAAiB,GAAG,CAACI,MAAD,EAASS,OAAT,KAAqB;AAC7ClB,IAAAA,MAAM,CAAC0B,WAAP,CACE;AACEjB,MAAAA,MADF;AAEES,MAAAA;AAFF,KADF,EAKE,GALF;AAOD,GARD;;AAUA,QAAMd,uBAAuB,GAAG,CAACvB,gBAAD,EAAmB8C,IAAnB,KAA4B;AAC1D,QAAIA,IAAI,KAAKC,SAAb,EAAwB;AACtB,aAAO;AACL/C,QAAAA,gBAAgB,EAAEA,gBADb;AAELgD,QAAAA,iBAAiB,EAAEnE,gBAAgB,CACjCS,aAAa,CAAC2D,mBAAd,CAAkCC,aAAlC,CAAgDC,OADf;AAF9B,OAAP;AAMD,KAPD,MAOO;AACLC,MAAAA,OAAO,CAACC,GAAR,CAAY,yCAAZ,EAAuDP,IAAvD;AACA,aAAO;AACL9C,QAAAA,gBAAgB,EAAEA,gBADb;AAELgD,QAAAA,iBAAiB,EAAEnE,gBAAgB,CACjCS,aAAa,CAAC2D,mBAAd,CAAkCC,aAAlC,CAAgDC,OADf,CAF9B;AAKLpB,QAAAA,SAAS,EAAEe;AALN,OAAP;AAOD;AACF,GAlBD;;AAoBA,QAAMhB,8BAA8B,GAAG9B,gBAAgB,IAAI;AACzD,QACEmB,MAAM,CAACmC,kBAAP,IACAZ,KAAK,CAACa,OAAN,CAAcpC,MAAM,CAACmC,kBAArB,CADA,IAEAnC,MAAM,CAACmC,kBAAP,CAA0BtB,MAH5B,EAIE;AACA,UAAIwB,OAAO,GACTrC,MAAM,CAACmC,kBAAP,CAA0BnC,MAAM,CAACmC,kBAAP,CAA0BtB,MAA1B,GAAmC,CAA7D,CADF;;AAEA,UAAIwB,OAAO,CAACC,cAAR,CAAuB,UAAvB,CAAJ,EAAwC;AACtC,aAAK,IAAI,CAAClD,GAAD,EAAM+B,KAAN,CAAT,IAAyBkB,OAAO,CAACvD,QAAjC,EAA2C;AACzCD,UAAAA,gBAAgB,CAACO,GAAD,CAAhB,CAAsBN,QAAtB,GAAiCyC,KAAK,CAACgB,IAAN,CAAWpB,KAAX,CAAjC;AACD;AACF;;AACD,UAAIkB,OAAO,CAACC,cAAR,CAAuB,yBAAvB,CAAJ,EAAuD;AACrD,aAAK,IAAI,CAAClD,GAAD,EAAM+B,KAAN,CAAT,IAAyBkB,OAAO,CAACtC,uBAAjC,EAA0D;AACxDlB,UAAAA,gBAAgB,CAACO,GAAD,CAAhB,CAAsBW,uBAAtB,GAAgDwB,KAAK,CAACgB,IAAN,CAAWpB,KAAX,CAAhD;AACD;AACF;AACF;;AACD,WAAOtC,gBAAP;AACD,GApBD,CAjL+C,CAuM/C;AACA;;;AACA,QAAM2D,aAAa,GAAItB,OAAD,IAAa;AACjC,QAAItB,IAAI,GAAGsB,OAAO,CAACtB,IAAnB;AACAqC,IAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;AACD,GAHD,CAzM+C,CA8M/C;;;AACA,QAAMnB,oBAAoB,GAAG,MAAMR,GAAN,IAAa;AACxC;AACA;AACA;AACAzC,IAAAA,eAAe,GAAG,IAAlB;AACA,UAAMc,YAAY,CAACF,SAAS,CAAC6B,GAAG,CAACC,IAAJ,CAASU,OAAT,CAAiBuB,aAAlB,CAAV,CAAlB;AACD,GAND,CA/M+C,CAuN/C;;;AACAlF,EAAAA,qCAAqC,CAAC,CAAC;AAACgB,IAAAA;AAAD,GAAD,KAAgB;AACpD,UAAMmE,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAZ;;AACA,QAAIF,GAAG,GAAG3E,aAAN,GAAsBC,aAA1B,EAAyC;AACvCF,MAAAA,eAAe,GAAG,IAAlB;AACD,KAFD,MAEO;AACLC,MAAAA,aAAa,GAAG2E,GAAhB;AACD;;AAED,QAAI,CAAC5E,eAAL,EAAsB;AACpBa,MAAAA,YAAY,CAAC,CAAC,GAAGD,SAAJ,EAAeH,QAAf,CAAD,CAAZ;AACD;AACF,GAXoC,CAArC;AAaA,SAAO,IAAP;AACD","sourcesContent":["import React, {useState, useEffect} from 'react';\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilSnapshot,\n  useGotoRecoilSnapshot,\n} from 'recoil';\nimport {formatFiberNodes} from './formatFiberNodes';\n\n// grabs isPersistedState from sessionStorage\nlet isPersistedState = sessionStorage.getItem('isPersistedState');\n\n// isRestored state disables snapshots from being recorded\n// when we jump backwards\nlet isRestoredState = false;\n\n// set default throttle to 70, throttle timer changes with every snapshot\nlet throttleTimer = 0;\nlet throttleLimit = 70;\n\n// persistedSnapshots initially null\n// let persistedSnapshots = null;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n\n  // Define a recoilizeRoot variable which will be assigned based on whether a root is passed in as a prop\n  let recoilizeRoot;\n\n  // Check if a root was passed to props.\n  if (props.root) {\n    const {root} = props;\n    recoilizeRoot = root;\n  } else {\n    recoilizeRoot = document.getElementById('root');\n  }\n\n  const snapshot = useRecoilSnapshot();\n\n  // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\n  const nodes = [...snapshot.getNodes_UNSTABLE()];\n\n  // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n  const [snapshots, setSnapshots] = useState([snapshot]);\n  // const [isRestoredState, setRestoredState] = useState(false);\n  const gotoSnapshot = useGotoRecoilSnapshot();\n\n  const filteredSnapshot = {};\n\n  /*\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \n  This object will then be used to construct a nodeSubscriptions object. \n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \n  */\n\n  const nodeDeps = {};\n  const nodeSubscriptions = {};\n\n  nodes.forEach(node => {\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\n  });\n\n  for (let key in nodeDeps) {\n    nodeDeps[key].forEach(node => {\n      if (nodeSubscriptions[node]) {\n        nodeSubscriptions[node].push(key);\n      } else {\n        nodeSubscriptions[node] = [key];\n      }\n    });\n  }\n\n  // Traverse all atoms and selector state nodes and get value\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents;\n    // Construct node data structure for dev tool to consume\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps[node.key],\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key]\n        ? nodeSubscriptions[node.key]\n        : [],\n    };\n  });\n\n  // React lifecycle hook on re-render\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener('message', onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot);\n      // Post message to content script on every re-render of the developers application only if content script has started\n      sendWindowMessage('recordSnapshot', devToolData);\n    } else {\n      isRestoredState = false;\n    }\n\n    // Clears the window event listener.\n    return () => window.removeEventListener('message', onMessageReceived);\n  });\n\n  // Listener callback for messages sent to windowf\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case 'contentScriptStarted':\n        if (isPersistedState === 'false' || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(\n            filteredSnapshot,\n          );\n\n          //creating a indexDiff variable\n          //only created on initial creation of devToolData\n          //determines difference in length of backend snapshots array and frontend snapshotHistoryLength to avoid off by one error\n          const indexDiff = snapshots.length - 1;\n\n          const devToolData = createDevToolDataObject(\n            initialFilteredSnapshot,\n            indexDiff,\n          );\n          sendWindowMessage('moduleInitialized', devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage('persistSnapshots', null);\n        }\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n      case 'snapshotTimeTravel':\n        timeTravelToSnapshot(msg);\n        break;\n      case 'persistState':\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n      case 'throttleEdit':\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n      default:\n        break;\n    }\n  };\n\n  // assigns or switches isPersistedState in sessionStorage\n  const switchPersistMode = () => {\n    if (isPersistedState === 'false' || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem('isPersistedState', true);\n\n      // stores the length of current list of snapshots in sessionStorage\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem('isPersistedState', false);\n    }\n  };\n\n  // function retreives length and fills snapshot array\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem('persistedSnapshots');\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  };\n\n  // Sends window an action and payload message.\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage(\n      {\n        action,\n        payload,\n      },\n      '*',\n    );\n  };\n\n  const createDevToolDataObject = (filteredSnapshot, diff) => {\n    if (diff === undefined) {\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(\n          recoilizeRoot._reactRootContainer._internalRoot.current,\n        ),\n      };\n    } else {\n      console.log('logging diff from create Dev tool data:', diff);\n      return {\n        filteredSnapshot: filteredSnapshot,\n        componentAtomTree: formatFiberNodes(\n          recoilizeRoot._reactRootContainer._internalRoot.current,\n        ),\n        indexDiff: diff,\n      };\n    }\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (\n      window.$recoilDebugStates &&\n      Array.isArray(window.$recoilDebugStates) &&\n      window.$recoilDebugStates.length\n    ) {\n      let snapObj =\n        window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n      if (snapObj.hasOwnProperty('nodeDeps')) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n    return filteredSnapshot;\n  };\n\n  // Will add hover effect over highlighted component\n  // Takes an argument of msg.data which contains name and payload\n  const activateHover = (payload) => {\n    let name = payload.name;\n    console.log('hello from index.js');\n  }\n\n  // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n  const timeTravelToSnapshot = async msg => {\n    // await setRestoredState(true);\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n    // await setRestoredState(false);\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  };\n\n  // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n  useRecoilTransactionObserver_UNSTABLE(({snapshot}) => {\n    const now = new Date().getTime();\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}