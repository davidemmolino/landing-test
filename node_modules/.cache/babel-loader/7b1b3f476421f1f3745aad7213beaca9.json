{"ast":null,"code":"// node parameter should be root of the fiber node tree, can be grapped with startNode from below\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\nconst formatFiberNodes = node => {\n  const formattedNode = {\n    // this function grabs a 'name' based on the tag of the node\n    name: assignName(node),\n    tag: node.tag,\n    children: [],\n    recoilNodes: createAtomsSelectorArray(node),\n    actualDuration: node.actualDuration,\n    treeBaseDuration: node.treeBaseDuration,\n    wasSuspended: node.return && node.return.tag === 13 ? true : false\n  }; // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\n\n  let currentNode = node.child;\n\n  while (currentNode) {\n    formattedNode.children.push(formatFiberNodes(currentNode));\n    currentNode = currentNode.sibling;\n  }\n\n  return formattedNode;\n};\n\nconst createAtomsSelectorArray = node => {\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\n  const recoilNodes = []; //start the pointer at node.memoizedState. All nodes should have this key.\n\n  let currentNode = node.memoizedState; // Traverse through the memoizedStates and look for the deps key which holds selectors or state.\n\n  while (currentNode) {\n    // if the memoizedState has a deps key, and that deps key is an array of length 2 then the first value of that array will be an atom or selector\n    if (currentNode.deps && Array.isArray(currentNode.deps) && currentNode.deps.length === 2) {\n      // if the atom/selector already exist in the recoilNodes array then break from this while loop. At this point you are traversing through previous atom/selector deps.\n      if (recoilNodes.includes(currentNode.deps[0].key)) break;\n      recoilNodes.push(currentNode.deps[0].key); // if an atom/selector was successfully pushed into the recoilNodes array then the pointer should now point to the next key, which will have its own deps key if there is another atom/selector\n\n      currentNode = currentNode.next;\n    } else {\n      // This is the case where there is no atom/selector in the memoizedState. Look into the memoized state of the next key. If that doesn't exist then break from the while loop because there are no atoms/selectors at this point.\n      if (!currentNode.next) break;\n      if (!currentNode.next.memoizedState) break;\n      currentNode = currentNode.next.memoizedState;\n    }\n  }\n\n  return recoilNodes;\n}; // keep an eye on this section as we test bigger and bigger applications SEAN\n\n\nconst assignName = node => {\n  // Returns symbol key if $$typeof is defined. Some components, such as context providers, will have this value.\n  if (node.type && node.type.$$typeof) return Symbol.keyFor(node.type.$$typeof); // Return suspense if tag is equal to 13, which is associated with Suspense components.\n\n  if (node.tag === 13) return 'Suspense'; // Find name of a class component\n\n  if (node.type && node.type.name) return node.type.name; // Tag 5 === HostComponent\n\n  if (node.tag === 5) return `${node.type}`; // Tag 3 === HostRoot\n\n  if (node.tag === 3) return 'HR'; // Tag 6 === HostText\n\n  if (node.tag === 6) return node.memoizedProps; // Tag 7 === Fragment\n\n  if (node.tag === 7) return 'Fragment';\n};\n\nmodule.exports = {\n  formatFiberNodes\n}; // if testing this function on the browser, use line below to log the formatted tree in the console\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)","map":{"version":3,"sources":["/home/davide/Desktop/Recoilize-landing-page/node_modules/recoilize/formatFiberNodes.js"],"names":["formatFiberNodes","node","formattedNode","name","assignName","tag","children","recoilNodes","createAtomsSelectorArray","actualDuration","treeBaseDuration","wasSuspended","return","currentNode","child","push","sibling","memoizedState","deps","Array","isArray","length","includes","key","next","type","$$typeof","Symbol","keyFor","memoizedProps","module","exports"],"mappings":"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","sourcesContent":["// node parameter should be root of the fiber node tree, can be grapped with startNode from below\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\n\nconst formatFiberNodes = node => {\n  const formattedNode = {\n    // this function grabs a 'name' based on the tag of the node\n    name: assignName(node),\n    tag: node.tag,\n    children: [],\n    recoilNodes: createAtomsSelectorArray(node),\n    actualDuration: node.actualDuration,\n    treeBaseDuration: node.treeBaseDuration,\n    wasSuspended: node.return && node.return.tag === 13 ? true : false,\n  };\n\n  // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\n  let currentNode = node.child;\n  while (currentNode) {\n    formattedNode.children.push(formatFiberNodes(currentNode));\n    currentNode = currentNode.sibling;\n  }\n\n  return formattedNode;\n};\n\nconst createAtomsSelectorArray = node => {\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\n  const recoilNodes = [];\n\n  //start the pointer at node.memoizedState. All nodes should have this key.\n  let currentNode = node.memoizedState;\n\n  // Traverse through the memoizedStates and look for the deps key which holds selectors or state.\n  while (currentNode) {\n    // if the memoizedState has a deps key, and that deps key is an array of length 2 then the first value of that array will be an atom or selector\n    if (\n      currentNode.deps &&\n      Array.isArray(currentNode.deps) &&\n      currentNode.deps.length === 2\n    ) {\n      // if the atom/selector already exist in the recoilNodes array then break from this while loop. At this point you are traversing through previous atom/selector deps.\n      if (recoilNodes.includes(currentNode.deps[0].key)) break;\n      recoilNodes.push(currentNode.deps[0].key);\n\n      // if an atom/selector was successfully pushed into the recoilNodes array then the pointer should now point to the next key, which will have its own deps key if there is another atom/selector\n      currentNode = currentNode.next;\n    } else {\n      // This is the case where there is no atom/selector in the memoizedState. Look into the memoized state of the next key. If that doesn't exist then break from the while loop because there are no atoms/selectors at this point.\n      if (!currentNode.next) break;\n      if (!currentNode.next.memoizedState) break;\n      currentNode = currentNode.next.memoizedState;\n    }\n  }\n  return recoilNodes;\n};\n\n// keep an eye on this section as we test bigger and bigger applications SEAN\nconst assignName = node => {\n  // Returns symbol key if $$typeof is defined. Some components, such as context providers, will have this value.\n  if (node.type && node.type.$$typeof) return Symbol.keyFor(node.type.$$typeof);\n  // Return suspense if tag is equal to 13, which is associated with Suspense components.\n  if (node.tag === 13) return 'Suspense';\n  // Find name of a class component\n  if (node.type && node.type.name) return node.type.name;\n  // Tag 5 === HostComponent\n  if (node.tag === 5) return `${node.type}`;\n  // Tag 3 === HostRoot\n  if (node.tag === 3) return 'HR';\n  // Tag 6 === HostText\n  if (node.tag === 6) return node.memoizedProps;\n  // Tag 7 === Fragment\n  if (node.tag === 7) return 'Fragment';\n};\n\nmodule.exports = {formatFiberNodes};\n\n// if testing this function on the browser, use line below to log the formatted tree in the console\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)\n"]},"metadata":{},"sourceType":"script"}